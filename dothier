#!/usr/bin/env bash
#
# Copyright (c) 2020-2021, Chris 'sh0shin' Frage
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# dothier - Manage dotfiles hierarchy

set -o pipefail -eu

# self, version, url
readonly dothier_self="$(basename "$0")"
readonly dothier_version="v0.1.4-beta.2"
readonly dothier_url="https://sh0shin.org/dothier"

# default options
# -C
dothier_color=true
# -D
dothier_debug=false
# -g
dothier_gitpull=false
# -k
dothier_kill=false
# -l
dothier_deadlink=false
# -r
dothier_recursive=false
# -v
dothier_verbose=false
# -f file
dothier_file=".hier"
# -d dir
dothier_dir="$HOME/.dotfiles"
# -H home
dothier_home="$HOME"

# dothier file defaults
: "${dothier_file_dirmode:=0755}"
: "${dothier_file_filemode:=0644}"
: "${dothier_file_link:=no}"
: "${dothier_file_gitpull:=no}"
: "${dothier_file_gitdepth:=1}"
: "${dothier_file_tmex:=0}"
: "${dothier_file_touch:=0}"

omsg()
{
  local level="$1"
  local msg="${2:-}"

  # dothier colors
  # Black        0;30   Dark Gray    1;30
  # Red          0;31   Light Red    1;31
  # Green        0;32   Light Green  1;32
  # Brown/Orange 0;33   Yellow       1;33
  # Blue         0;34   Light Blue   1;34
  # Purple       0;35   Light Purple 1;35
  # Cyan         0;36   Light Cyan   1;36
  # Light Gray   0;37   White        1;37

  local c_debug=''
  local c_error=''
  local c_gitverbose=''
  local c_info=''
  local c_recursive=''
  local c_verbose=''
  local c_warning=''
  local c_none=''

  if [[ "$dothier_color" == true ]]
  then
    c_debug='\033[1;34m'
    c_error='\033[1;31m'
    c_gitverbose='\033[1;35m'
    c_info='\033[0;36m'
    c_recursive='\033[0;33m'
    c_verbose='\033[1;36m'
    c_warning='\033[1;33m'
    c_none='\033[0m'
  fi

  # info
  if [[ "$level" == "i" ]]
  then
    echo -e "${c_info}[I] $msg${c_none}"
  fi

  # warning
  if [[ "$level" == "w" ]]
  then
    echo -e "${c_warning}[W] $msg${c_none}"
  fi

  # error
  if [[ "$level" == "e" ]]
  then
    echo -e "${c_error}[E] $msg${c_none}"
  fi

  # recursive
  if [[ "$level" == "r" ]]
  then
    echo -e "${c_recursive}[R] $msg${c_none}"
  fi

  # verbose
  if [[ "$level" == "v" ]] && [[ "$dothier_verbose" == true ]]
  then
    echo -e "${c_verbose}[V] $msg${c_none}"
  fi

  # git verbose
  if [[ "$level" == "g" ]] && [[ "$dothier_verbose" == true ]]
  then
    echo -ne "$c_gitverbose"
  fi

  # debug
  if [[ "$level" == "d" ]] && [[ "$dothier_debug" == true ]]
  then
    echo -e "${c_debug}[D] $msg${c_none}"
  fi

  # none
  if [[ "$level" == "n" ]]
  then
    echo -ne "$c_none"
  fi
}

check_support()
{
  case "$OSTYPE" in
    darwin*|freebsd*|openbsd*|linux*)
      true
      ;;
    *)
      omsg e "UNSUPPORTED OSTYPE=$OSTYPE"
      exit 1
      ;;
  esac
}

show_usage()
{
  echo "$dothier_self $dothier_version ( $dothier_url )"
  echo "Usage: $dothier_self [-CDhklrv] [-f file] [-d dir] [-H home]"
}

show_help()
{
  show_usage
  echo "Options:"
  echo "  -C      : Disable colorized output"
  echo "  -D      : Enable verbose & debug output"
  echo "  -g      : Enable git pull (default: $dothier_gitpull)"
  echo "  -h      : Show this help"
  echo "  -k      : Enable kill/remove mode (default: $dothier_kill)"
  echo "  -l      : Enable dead link search (default: $dothier_deadlink)"
  echo "  -r      : Enable recursive mode (default: $dothier_recursive)"
  echo "  -v      : Enable verbose output (default: $dothier_verbose)"
  echo "  -f file : The .hier file (default: $dothier_file in recursive mode)"
  echo "  -d dir  : Use dotfiles directory in recursive mode (default: $dothier_dir)"
  echo "  -H home : Home directory (default: $dothier_home)"
  echo
}

# stat_mode <path>
stat_mode()
{
  local path="$1"
  local stat

  case "$OSTYPE" in
    darwin*|freebsd*|openbsd*)
      stat="$(stat -f "%Mp%Lp" "$path")"
      ;;
    linux*)
      stat="$(stat -c "%#a" "$path")"
      ;;
  esac
  echo "$stat"
}

# sane_mode <mode> <type>
sane_mode()
{
  local mode="$1"
  local type="$2"

  # mode sanity
  if [[ "$type" == "dir" ]] || [[ "$type" == "ldir" ]]
  then
    if [[ "${mode:1:4}" -lt 500 ]] || [[ "${mode:1:4}" -gt 775 ]]
    then
      omsg w "(mode)\tINSANE MODE=$mode PATH=$path TYPE=$type"
      return 1
    fi
  fi

  if [[ "$type" == "file" ]] || [[ "$type" == "lfile" ]]
  then
    if [[ "${mode:1:4}" -lt 400 ]] || [[ "${mode:1:4}" -gt 775 ]]
    then
      omsg w "(mode)\tINSANE MODE=$mode PATH=$path TYPE=$type"
      return 1
    fi
  fi
  return 0
}

# exec_mode <path> <mode>
exec_mode()
{
  local path="$1"
  local mode="$2"
  local type="$3"
  local _mode
  local _readlink

  # debug
  omsg d "(mode)\tEXEC PATH=$path MODE=$mode TYPE=$type"

  # delete mode
  if [[ "$mode" == "0000" ]]
  then

    # directory
    if [[ -d "$path" ]]
    then
      if [[ "$dothier_kill" == true ]]
      then
        omsg i "(mode)\tREMOVING PATH=$path TYPE=$type"
        rm -r "$path"
      else
        omsg w "(mode)\tNOT REMOVING PATH=$path TYPE=$type"
      fi

    # file
    elif [[ -f "$path" ]]
    then
      if [[ "$dothier_kill" == true ]]
      then
        omsg i "(mode)\tREMOVING PATH=$path TYPE=$type"
        rm "$path"
      else
        omsg w "(mode)\tNOT REMOVING PATH=$path TYPE=$type"
      fi

    # link
    elif [[ -L "$path" ]]
    then
      if [[ "$dothier_kill" == true ]]
      then
        omsg i "(mode)\tREMOVING PATH=$path TYPE=$type"
        rm "$path"
      else
        omsg w "(mode)\tNOT REMOVING PATH=$path TYPE=$type"
      fi
    fi
    return
  fi

  # check mode
  _mode="$(stat_mode "$path")"
  if [[ "$_mode" != "$mode" ]]
  then
    if [[ ! -L "$path" ]]
    then

      # directory
      if [[ -d "$path" ]]
      then
        omsg i "(mode)\tCHANGING MODE=$_mode > $mode PATH=$path TYPE=$type"
        chmod "$mode" "$path"
      fi

      # file
      if [[ -f "$path" ]]
      then
        omsg i "(mode)\tCHANGING MODE=$_mode > $mode PATH=$path TYPE=$type"
        chmod "$mode" "$path"
      fi
    else
      # linked directory
      _readlink="$(readlink "$path")"
      _mode="$(stat_mode "$_readlink")"

      if [[ "$_mode" != "$mode" ]]
      then
        omsg i "(mode)\tCHANGING MODE=$_mode > $mode PATH=$_readlink TYPE=$type"
        chmod "$mode" "$_readlink"
      else
        omsg v "(mode)\tOK MODE=$mode PATH=$_readlink TYPE=$type"
      fi
    fi
  else
    omsg v "(mode)\tOK MODE=$mode PATH=$path TYPE=$type"
  fi
}

# exec_link <root> <home> <path> <type> <mode> <link> <tmex>
exec_link()
{
  local root="$1"
  local home="$2"

  # dothier content
  local path="$3"
  local type="$4"
  local mode="$5"
  local link="$6"
  local tmex="$7"

  local root_path="$root/$path"
  local home_path="$home/$path"
  local orphaned=0

  omsg d "(link)\tEXEC ROOT=$root HOME=$home PATH=$path TYPE=$type MODE=$mode LINK=$link TMEX=$tmex"

  # delete mode
  if [[ "$mode" == 0000 ]] && [[ "$type" == "link" ]]
  then
    exec_mode "$home_path" "$mode" "$type"
    return
  fi

  # ldir || lfile
  if [[ "$type" == "ldir" ]] || [[ "$type" == "lfile" ]]
  then
    # unsupported link
    if [[ "$link" == "yes" ]] || [[ "$link" != "no" ]]
    then
      omsg w "(link)\tUNSUPPORTED TYPE=$type LINK=$link"
      return
    else
      # skip
      omsg d "(link)\tSKIPPING TYPE=$type"
      return
    fi
  fi

  # type dir || file
  if [[ "$type" == "dir" ]] || [[ "$type" == "file" ]]
  then
    if [[ "$link" != "yes" ]] && [[ "$link" != "no" ]]
    then
      home_path="$home/$link"
      omsg d "(link)\tSETTING HOME=$home_path"
    fi
  fi

  # type link
  if [[ "$type" == "link" ]]
  then
    if [[ "$link" != "yes" ]] && [[ "$link" != "no" ]]
    then

      if [[ "$link" =~ ^(/.*)?$ ]]
      then
        # absolute
        root_path="$link"
      elif [[ "$link" =~ ^(~/.*)?$ ]]
      then
        # ~ -> $HOME
        root_path="${link/\~/$home}"
      else
        # relative
        root_path="$root/$link"
      fi

      omsg d "(link)\tSETTING ROOT=$root_path"
    fi
  fi

  # check source
  if [[ ! -e "$root_path" ]] && [[ "$link" != "no" ]]
  then
    omsg e "(link)\tUNREADABLE TYPE=$type $root_path LINK=$link"
    return 1
  fi

  # check & clean destination
  # remove dir
  if [[ ! -L "$home_path" ]] && [[ -d "$home_path" ]] && [[ "$type" != "dir" ]]
  then
    if [[ "$dothier_kill" == true ]]
    then
      omsg i "(link)\tREMOVING WRONG DIRECTORY PATH=$home_path TYPE=$type"
      rm -r "$home_path"
    else
      omsg w "(link)\tWRONG DIRECTORY EXISTS PATH=$home_path TYPE=$type"
    fi
  fi

  # remove file
  if [[ ! -L "$home_path" ]] && [[ -f "$home_path" ]] && [[ "$type" != "file" ]]
  then
    if [[ "$dothier_kill" == true ]]
    then
      omsg i "(link)\tREMOVING WRONG FILE PATH=$home_path TYPE=$type"
      rm "$home_path"
    else
      omsg w "(link)\tWRONG FILE EXISTS PATH=$home_path TYPE=$type"
    fi
  fi

  # wrong link
  if [[ -L "$home_path" ]]
  then
    local _readlink
    _readlink="$(readlink "$home_path")"

    if [[ -n "$_readlink" ]]
    then
      # remove
      if [[ "$(readlink "$home_path")" != "$root_path" ]] && [[ "$link" != "no" ]]
      then
        if [[ "$dothier_kill" == true ]]
        then
          omsg i "(link)\tREMOVING WRONG LINK=$_readlink -> $home_path TYPE=$type"
          rm "$home_path"
        else
          omsg w "(link)\tLINK EXISTS LINK=$_readlink -> $home_path TYPE=$type"
        fi
      fi
    fi
  fi

  # no link
  if [[ -L "$home_path" ]] && [[ "$link" == "no" ]]
  then
    if [[ "$dothier_kill" == true ]]
    then
      omsg i "(link)\tREMOVING LINK=$home_path TYPE=$type"
      rm "$home_path"
    else
      omsg w "(link)\tNOT REMOVING LINK=$home_path TYPE=$type"
    fi
    return
  fi

  # create link
  if [[ "$link" != "no" ]]
  then
    # remove orphaned
    if [[ ! -L "$home_path" ]] && [[ -e "$home_path" ]]
    then
      if [[ "$dothier_kill" == true ]]
      then
        omsg i "(link)\tREMOVING PATH=$home_path TYPE=$type"
        rm "$home_path"
      else
        omsg w "(link)\tNOT LINKED DESTINATION EXISTS PATH=$home_path TYPE=$type"
        orphaned=1
      fi
    fi

    if [[ ! -L "$home_path" ]] && [[ "$link" != "no" ]] && [[ "$orphaned" -eq 0 ]]
    then
      omsg i "(link)\tCREATING LINK=$root_path -> $home_path TYPE=$type"
      ln -s "$root_path" "$home_path"
    else
      omsg v "(link)\tOK LINK=$root_path -> $home_path TYPE=$type"
    fi
  fi

  if [[ "$type" != "link" ]]
  then
    # pass tmutil
    exec_tmutil "$home_path" "$tmex" "$type"
  fi
}

# exec_dir <root> <home> <path> <type> <mode> <link> <tmex>
exec_dir()
{
  local root="$1"
  local home="$2"

  # dothier content
  local path="$3"
  local type="$4"
  local mode="$5"
  local link="$6"
  local tmex="$7"

  local root_path="$root/$path"
  local home_path="$home/$path"

  omsg d "(dir)\tEXEC ROOT=$root HOME=$home PATH=$path TYPE=$type MODE=$mode LINK=$link TMEX=$tmex"

  # delete mode
  # type ldir
  if [[ "$mode" == "0000" ]] && [[ "$type" == "ldir" ]]
  then
    exec_mode "$root_path" "$mode" "$type"
    return
  fi
  # type dir
  if [[ "$mode" == "0000" ]] && [[ "$type" == "dir" ]]
  then
    exec_mode "$home_path" "$mode" "$type"
    return
  fi

  # type ldir
  if [[ "$type" == "ldir" ]]
  then
    if [[ ! -d "$root_path" ]]
    then
      if [[ -e "$root_path" ]]
      then
        omsg e "(dir)\tNOT A DIRECTORY PATH=$root_path TYPE=$type"
        return
      else
        omsg i "(dir)\tCREATING PATH=$root_path TYPE=$type"
        mkdir -m "$mode" "$root_path"
      fi
    else
      omsg v "(dir)\tOK PATH=$root_path TYPE=$type"
      # pass mode
      exec_mode "$root_path" "$mode" "$type"
    fi
  fi

  # type dir
  if [[ "$type" == "dir" ]]
  then
    # check root
    if [[ ! -d "$root_path" ]] && [[ "$link" != "no" ]]
    then
      if [[ -e "$root_path" ]]
      then
        omsg e "(dir)\tNOT A DIRECTORY PATH=$root_path TYPE=$type"
        return
      else
        omsg e "(dir)\tNOT FOUND PATH=$root_path TYPE=$type"
        return
      fi
    fi

    # check home
    if [[ ! -d "$home_path" ]]
    then
      if [[ -e "$home_path" ]]
      then
        omsg e "(dir)\tNOT A DIRECTORY PATH=$home_path TYPE=$type"
        return
      fi
      # skip link
      if [[ "$link" == "no" ]]
      then
        omsg i "(dir)\tCREATING PATH=$home_path TYPE=$type"
        mkdir -m "$mode" "$home_path"
      fi
    else
      omsg v "(dir)\tOK PATH=$home_path TYPE=$type"
      # pass mode
      exec_mode "$home_path" "$mode" "$type"
    fi
  fi

  # pass link
  exec_link "$root" "$home" "$path" "$type" "$mode" "$link" "$tmex"
}

# exec_file <root> <home> <path> <type> <mode> <link> <tmex>
exec_file()
{
  local root="$1"
  local home="$2"

  # dothier content
  local path="$3"
  local type="$4"
  local mode="$5"
  local link="$6"
  local tmex="$7"

  local root_path="$root/$path"
  local home_path="$home/$path"

  omsg d "(file)\tEXEC ROOT=$root HOME=$home PATH=$path TYPE=$type MODE=$mode LINK=$link TMEX=$tmex"

  # delete mode
  if [[ "$mode" == "0000" ]]
  then
    exec_mode "$root_path" "$mode" "$type"
    exec_mode "$home_path" "$mode" "$type"
    return
  fi

  # source file
  if [[ ! -f "$root_path" ]]
  then
    omsg e "(file)\tNOT FOUND PATH=$root_path TYPE=$type"
    #omsg w "(file)\tCREATING PATH=$root_path TYPE=$type"
    #touch "$root_path"
    return
  else
    omsg v "(file)\tOK PATH=$root_path TYPE=$type"
  fi

  # mode
  exec_mode "$root_path" "$mode" "$type"

  # pass link
  exec_link "$root" "$home" "$path" "$type" "$mode" "$link" "$tmex"
}

# exec_git <root> <home> <path> <type> <gitpull> <gitdepth>
exec_git()
{
  local root="$1"
  local home="$2"

  local path="$3"
  local type="$4"
  local gitpull="$5"
  local gitdepth="$6"

  local root_path="$dothier_root/$path"
  local home_path

  if [[ "$type" == "lgit" ]]
  then
    home_path="$(dirname "$root/$path")"
  else
    home_path="$(dirname "$home/$path")"
  fi

  omsg d "(git)\tEXEC ROOT=$root HOME=$home PATH=$path TYPE=$type PULL=$gitpull DEPTH=$gitdepth TMEX=$tmex"

  local giturl gitname gitdir
  IFS=$' \t'
  while read -r giturl gitdst
  do
    # skip comments
    [[ "$giturl" =~ ^(#.*)?$ ]] && continue

    gitname="${giturl##*/}"
    gitdir="${gitname%*.git}"

    # tmutil exclusion
    if [[ "$gitdst" =~ ^@ ]]
    then
      tmex=1
      gitdst="${gitdst##@}"
    fi

    if [[ -n "$gitdst" ]]
    then
      # absolute path
      if [[ "$gitdir" =~ ^(/.*)?$ ]]
      then
        gitdst="$gitdst"
      else
        gitdst="$home_path/$gitdst"
      fi
    else
      gitdst="$home_path/$gitdir"
    fi

    omsg v "(git)\tURL=$giturl PATH=$gitdst"

    if [[ -d "$gitdst" ]]
    then
      if [[ "$gitpull" == "yes" ]]
      then
        omsg i "(git)\tPULLING PATH=$gitdst"
        omsg g
        (
          cd "$gitdst" || return
          if [[ "$dothier_verbose" == true ]]
          then
            git pull --verbose
          else
            git pull --quiet
          fi
        )
        omsg n
      fi
    else
      omsg i "(git)\tCLONING URL=$giturl PATH=$gitdst"
      omsg g
      (
        if [[ "$dothier_verbose" == true ]]
        then
          git clone --verbose --depth="$gitdepth" "$giturl" "$gitdst"
        else
          git clone --quiet --depth="$gitdepth" "$giturl" "$gitdst"
        fi
      )
      omsg n
    fi

    # pass tmutil
    exec_tmutil "$gitdst" "$tmex" "$type"

  done < "$root_path"
  unset IFS
}

# exec_tmutil <path> <tmex>
exec_tmutil()
{
  [[ "$OSTYPE" != darwin* ]] && return

  local path="$1"
  local tmex="$2"

  omsg d "(tmutil)\tEXEC PATH=$path TMEX=$tmex TYPE=$type"

  # destination
  if [[ -e "$path" ]]
  then
    if [[ -L "$path" ]] && [[ "$tmex" -eq 1 ]]
    then
      omsg e "(tmutil)\tUNSUPPORTED LINK PATH=$path"
      return
    fi

    if ( xattr "$path" | grep -q com_apple_backup_excludeItem )
    then
      if [[ "$tmex" -eq  0 ]]
      then
        omsg i "(tmutil)\tINCLUDING PATH=$path"
        tmutil removeexclusion "$path"
      else
        omsg v "(tmutil)\tOK PATH=$path"
      fi
    else
      if [[ "$tmex" -eq 1 ]]
      then
        omsg i "(tmutil)\tEXCLUDING PATH=$path"
        tmutil addexclusion "$path"
      fi
    fi
  fi
}

search_deadlink()
{
  local home="$1"
  local dead
  local link

  # dead links
  dead="$(find "$home" \( -name Library -o -name Volumes \) -prune -false -o -type l ! -exec test -e '{}' \; -print)"

  for link in $dead
  do
    if [[ "$dothier_kill" == true ]]
    then
      omsg i "(dead)\tREMOVING DEAD LINK=$link"
      rm "$link"
    else
      omsg w "(dead)\tNOT REMOVING DEAD LINK=$link"
    fi
  done
}

# read_dothier <dothier_file> <dothier_home>
read_dothier()
{
  local dothier_file
  local dothier_home
  local dothier_root
  local dothier_exec

  dothier_file="$1"
  dothier_home="$2"
  dothier_root="$(cd "$(dirname "$dothier_file")" && echo "$PWD")"

  # dothier file
  if [[ ! -e "$dothier_file" ]]
  then
    omsg e "(read) NOT FOUND $dothier_file"
    exit 1
  fi

  # create home
  if [[ ! -d "$dothier_home" ]]
  then
    omsg w "(read)\tNOT FOUND HOME=$dothier_home"
    omsg w "(read)\tCREATING HOME=$dothier_home"
    mkdir -p "$dothier_home"
  fi

  # git pull (-g)
  if [[ "$dothier_gitpull" == true ]]
  then
    if [[ -d "$dothier_root/.git" ]]
    then
      omsg i "(git)\tPULLING PATH=$dothier_root"
      omsg g
      (
        cd "$dothier_root" || return
        if [[ "$dothier_verbose" == true ]]
        then
          git pull --verbose
        else
          git pull --quiet
        fi
      )
      omsg n
    fi
  fi

  # read file
  IFS=$' \t'
  while read -r path type mode link
  do
    # skip comments
    if [[ "$path" =~ ^(#.*)?$ ]]
    then
      continue
    fi

    # tmutil exclusion
    tmex="${dothier_file_tmex}"
    if [[ "$mode" =~ ^@ ]]
    then
      mode="${mode##@}"
      tmex=1
    fi

    # execute type
    case "$type" in
      dir|ldir)
        dothier_exec="exec_dir"
        # default dirmode
        mode="${mode:-$dothier_file_dirmode}"
        ;;
      file|lfile)
        dothier_exec="exec_file"
        # default filemode
        mode="${mode:-$dothier_file_filemode}"
        ;;
      link|llink)
        dothier_exec="exec_link"
        ;;
      git|lgit)
        dothier_exec="exec_git"
        # default gitpull
        mode="${mode:-$dothier_file_gitpull}"
        # default gitdepth
        link="${link:-$dothier_file_gitdepth}"
        ;;
      *)
        echo "E: unknown type $type"
        return
        ;;
    esac

    # mode sanity
    sane_mode "$mode" "$type" || continue

    # default link
    link="${link:-$dothier_file_link}"

    if [[ "$(type -t "$dothier_exec")" == "function" ]]
    then
      # exec type
      "$dothier_exec" "$dothier_root" "$dothier_home" \
        "$path" "$type" "$mode" "$link" "$tmex"
    else
      omsg e "(read)\tNO SUCH TYPE=$dothier_exec"
    fi

  done < "$dothier_file"
  unset IFS
}

# read_dothier_recursive <dothier_file> <dothier_home> <dothier_dir>
read_dothier_recursive()
{
  local dothier_file
  local dothier_home
  local dothier_dir
  local dothier_found
  local dothier_found_for
  local dothier_found_dirname

  dothier_file="$1"
  dothier_home="$2"
  dothier_dir="$3"
  dothier_found="$(find "$dothier_dir" -type f -iname "$dothier_file" | sort -u)"

  for dothier_found_for in $dothier_found
  do
    dothier_found_dirname="$(dirname "$dothier_found_for")"
    omsg r "(dothier)\tPATH=$dothier_found_dirname"
    read_dothier "$dothier_found_for" "$dothier_home"
  done
}

# supported
check_support

# options
while getopts ":CDghklrvf:d:H:" opt
do
  case $opt in
    C)
      dothier_color=false
      ;;
    D)
      dothier_debug=true
      dothier_verbose=true
      ;;
    g)
      dothier_gitpull=true
      ;;
    h)
      show_help
      exit 1
      ;;
    k)
      dothier_kill=true
      ;;
    l)
      dothier_deadlink=true
      ;;
    r)
      dothier_recursive=true
      ;;
    v)
      dothier_verbose=true
      ;;
    f)
      dothier_file="$OPTARG"
      ;;
    d)
      dothier_dir="$OPTARG"
      ;;
    H)
      dothier_home="$OPTARG"
      ;;
    \?)
      echo "-$OPTARG is invalid!"
      show_usage
      exit 1
      ;;
    :)
      echo "-$OPTARG requires an argument!"
      show_usage
      exit 1
      ;;
    *)
      show_usage
      exit 1
      ;;
  esac
done

# check
if [[ "$OPTIND" -eq 1 ]] || [[ "$OPTIND" -lt "$#" ]]
then
  show_usage
  exit 1
fi

# main
if [[ "$dothier_recursive" == true ]]
then
  read_dothier_recursive "$dothier_file" "$dothier_home" "$dothier_dir"
else
  read_dothier "$dothier_file" "$dothier_home"
fi

if [[ "$dothier_deadlink" == true ]]
then
  search_deadlink "$dothier_home"
fi
