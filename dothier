#!/usr/bin/env bash
#

# defaults
dothome="$HOME"
dothier=".hier"
dotdir="$HOME/.dotfiles"

def_dirmode="0755"
def_filemode="0644"
def_link="no"
def_gitpull="no"
def_gitdepth="1"

# debug
debug="no"

# recursive
recursive="no"

# git pull
gitpull="no"

# version
readonly dotself="$(basename "$0")"
readonly dotversion="v0.1.0-beta"
readonly doturl="https://sh0shin.org/dothier"

check_support()
{
  case "$OSTYPE" in
    darwin*|freebsd*|openbsd*|linux*)
      true
      ;;
    *)
      echo "E: unsupported OS $OSTYPE"
      exit
      ;;
  esac
} # check_support

show_usage()
{
  echo "$dotself $dotversion ( $doturl )"
  echo "Usage: $dotself [-Dhr] [-f file] [-d dir] [-H home]"
} # show_usage

show_help()
{
  show_usage
  echo "Options:"
  echo "  -D      : Enable debug output"
  echo "  -h      : Show this help"
  echo "  -r      : Enabled recursive mode (default $recursive)"
  echo "  -g      : Enable git pull (default $gitpull)"
  echo "  -f file : The .hier file to use (default $dothier)"
  echo "  -d dir  : Use directory for recursive mode (default: $dotdir)"
  echo "  -H home : Home directory (default $dothome)"
  echo
} # show_help

stat_mode()
{
  local path
  path="${1:-/dev/null}"

  case "$OSTYPE" in
    darwin*|freebsd*|openbsd*)
      stat="$(stat -f "%Mp%Lp" "$path")"
      ;;
    linux*)
      stat="$(stat -c "%#a" "$path")"
      ;;
  esac
  echo "$stat"
} # stat_mode

change_mode()
{
  local path mode
  path="$1"
  mode="$2"

  case "$OSTYPE" in
    darwin*|freebsd*|openbsd*)
      chmod -h "$mode" "$path"
      ;;
    linux*)
      [[ ! -L "$path" ]] && echo chmod "$mode" "$path"
      ;;
    esac
} # change_mode

dotexec_link()
{
  local src="$1"
  local dst="$2"
  local path="$3"
  local type="$4"
  local mode="${5:-$def_filemode}"
  local link="${6:-$def_link}"

  local src_path="$src/$path"
  local dst_path="$dst/$path"

  [[ "$debug" == "yes" ]] && echo "${FUNCNAME[0]}" "$@"

  # dir & file
  if [[ "$type" == "dir" ]] || [[ "$type" == "file" ]]
  then

    if [[ "$link" != "yes" ]] \
      && [[ "$link" != "no" ]]
    then
      dst_path="$dst/$link"
    fi

  # link
  elif [[ "$type" == "link" ]]
  then

    if [[ "$link" != "yes" ]] \
      && [[ "$link" != "no" ]]
    then

      # absolute link
      if [[ "$link" =~ ^(/.*)?$ ]]
      then
        src_path="$link"

      # relative link
      else
        src_path="$src/$link"
      fi
    fi
  fi

  # check source
  if [[ ! -e "$src_path" ]]
  then
    echo "E: $src_path not readable!"
    return
  fi

  # check destination
  # remove dir
  if [[ ! -L "$dst_path" ]] \
    && [[ -d "$dst_path" ]] \
    && [[ "$type" != "dir" ]]
  then
    rm -r "$dst_path"
  fi

  # remove file
  if [[ ! -L "$dst_path" ]] \
    && [[ -f "$dst_path" ]] \
    && [[ "$type" != "file" ]]
  then
    rm "$dst_path"
  fi

  # wrong link
  if [[ "$(readlink "$dst_path")" != "$src_path" ]] \
    && [[ "$link" != "no" ]]
  then

    # remove dir
    if [[ -d "$dst_path" ]]
    then
      rm -r "$dst_path"

    # remove file
    else
      rm -f "$dst_path"
    fi
  fi

  # remove no link
  if [[ -L "$dst_path" ]] \
    && [[ "$link" == "no" ]]
  then
    rm "$dst_path"
    return
  fi

  # delete mode
  if [[ "$mode" == "0000" ]]
  then
    if [[ -L "$dst_path" ]]
    then
      echo rm "$dst_path"
      return
    fi
  fi

  # create link
  if [[ "$link" != "no" ]]
  then
    if [[ ! -L "$dst_path" ]]
    then
      ln -s "$src_path" "$dst_path"
    fi
  fi
} # dotexec_link

dotexec_dir()
{
  local src="$1"
  local dst="$2"
  local path="$3"
  local type="$4"
  local mode="${5:-$def_dirmode}"
  local link="${6:-$def_link}"

  local src_path="$src/$path"
  local dst_path="$dst/$path"

  [[ "$debug" == "yes" ]] && echo "${FUNCNAME[0]}" "$@"

  # delete mode
  if [[ "$mode" == "0000" ]]
  then

    # source
    if [[ -e "$src_path" ]]
    then
      rm -r "$src_path"

      # local only
      if [[ "$type" == "ldir" ]]
      then
        return
      fi
    fi

    # destination
    if [[ -e "$dst_path" ]]
    then
      rm -r "$dst_path"
    fi

    return
  fi

  # check source
  if [[ ! -d "$src_path" ]]
  then

    if [[ -e "$src_path" ]]
    then
      echo "E: $src_path exists and is not a directory!"
      return
    fi

    mkdir -m "$mode" "$src_path"
  fi

  if [[ "$(stat_mode "$src_path")" != "$mode" ]]
  then
    change_mode "$src_path" "$mode"
  fi

  # not local
  if [[ "$type" != "ldir" ]]
  then

    # check destination
    if [[ ! -d "$dst_path" ]] \
      && [[ "$link" == "no" ]]
    then

      if [[ -e "$dst_path" ]]
      then
        echo "W: $dst_path exists!"
      fi

      mkdir -m "$mode" "$dst_path"
    fi

    if [[ "$link" == "no" ]]
    then
      if [[ "$(stat_mode "$dst_path")" != "$mode" ]]
      then
        change_mode "$dst_path" "$mode"
      fi
    fi

    # pass linking
    dotexec_link "$src" "$dst" "$path" "$type" "$mode" "$link"
  fi
} # dotexec_dir

dotexec_file()
{
  local src="$1"
  local dst="$2"
  local path="$3"
  local type="$4"
  local mode="${5:-$def_filemode}"
  local link="${6:-$def_link}"

  local src_path="$src/$path"
  local dst_path="$dst/$path"

  [[ "$debug" == "yes" ]] && echo "${FUNCNAME[0]}" "$@"

  # delete mode
  if [[ "$mode" == "0000" ]]
  then

    # source
    if [[ -e "$src_path" ]]
    then
      rm "$src_path"

      # local only
      if [[ "$type" == "lfile" ]]
      then
        return
      fi
    fi

    # destination
    if [[ -e "$dst_path" ]]
    then
      rm "$dst_path"
    fi

    # done
    return
  fi

  # check source
  if [[ ! -e "$src_path" ]]
  then
    echo "E: $src_path not found!"
    return
  fi

  if [[ "$(stat_mode "$src_path")" != "$mode" ]]
  then
    change_mode "$src_path" "$mode"
  fi

  # pass linking
  if [[ "$type" != "lfile" ]]
  then
    dotexec_link "$src" "$dst" "$path" "$type" "$mode" "$link"
  fi
} # dotexec_file

dotexec_git()
{
  local src="$1"
  local dst="$2"
  local path="$3"
  local type="$4"
  local gitpull="${5:-$def_gitpull}"
  local gitdepth="${6:-$def_gitdepth}"

  local src_path="$src/$path"
  local dst_path

  if [[ "$type" == "lgit" ]]
  then
    dst_path="$(dirname "$src/$path")"
  else
    dst_path="$(dirname "$dst/$path")"
  fi

  [[ "$debug" == "yes" ]] && echo "${FUNCNAME[0]}" "$@"

  local giturl gitname gitdir
  while IFS=$' \t' read -r giturl gitdst
  do
    # skip comments
    [[ "$giturl" =~ ^(#.*)?$ ]] && continue

    gitname="${giturl##*/}"
    gitdir="${gitname%*.git}"

    if [[ -n "$gitdst" ]]
    then
      # absolute path
      if [[ "$gitdir" =~ ^(/.*)?$ ]]
      then
        gitdst="$gitdst"
      else
        gitdst="$dst_path/$gitdst"
      fi
    else
      gitdst="$dst_path/$gitdir"
    fi

    echo " : git: $giturl -> $gitdst"

    if [[ -d "$gitdst" ]]
    then
      if [[ "$gitpull" == "yes" ]]
      then
        ( cd "$gitdst" && git pull -q )
      fi
    else
      ( git clone -q --depth "$gitdepth" "$giturl" "$gitdst" )
    fi

  done < "$src_path"
} # dotexec_git

read_dothier()
{
  local hier src dst path type mode link dotexec

  hier="$1"
  src="$(cd "$(dirname "$hier")" && echo "$PWD")"
  dst="$2"

  if [[ ! -e "$hier" ]]
  then
    echo "E: file $hier not found!"
    show_help
    return
  fi

  # git pull
  if [[ "$gitpull" == "yes" ]]
  then
    if [[ -d "$src/.git" ]]
    then
      ( cd "$src" && git pull )
    fi
  fi

  while IFS=$' \t' read -r path type mode link
  do
    # skip comments
    [[ "$path" =~ ^(#.*)?$ ]] && continue

    # execute type
    case "$type" in
      dir|ldir)
        dotexec="dotexec_dir"
        ;;
      file|lfile)
        dotexec="dotexec_file"
        ;;
      link|llink)
        dotexec="dotexec_link"
        ;;
      git|lgit)
        dotexec="dotexec_git"
        ;;
      *)
        echo "E: unknown type $type"
        return
        ;;
    esac

    if [[ "$(type -t "$dotexec")" == "function" ]]
    then
      "$dotexec" "$src" "$dst" "$path" "$type" "$mode" "$link"
    else
      echo "E: no such function $dotexec"
    fi

  done < "$hier"
} # read_dothier

dothier_recursive()
{
  local hier hier_path hier_name dst src

  hier="$1"
  dst="$2"
  src="$3"
  hier_path="$(find "$src" -iname "$hier" | sort -u)"

  for path in $hier_path
  do
    hier_name="$(basename "$(dirname "$path")")"
    echo ": $hier_name"
    read_dothier "$path" "$dst"
  done
} # dothier_recursive

# supported
check_support

# options
while getopts ":Dhrgf:d:H:" opt
do
  case $opt in
    D)
      debug="yes"
      set -x
      ;;
    h)
      show_help
      exit 1
      ;;
    r)
      recursive="yes"
      ;;
    g)
      gitpull="yes"
      ;;
    f)
      dothier="$OPTARG"
      ;;
    d)
      dotdir="$OPTARG"
      ;;
    H)
      dothome="$OPTARG"
      ;;
    \?)
      echo "-$OPTARG is invalid!"
      show_usage
      exit 1
      ;;
    :)
      echo "-$OPTARG requires an argument!"
      show_usage
      exit 1
      ;;
    *)
      show_usage
      exit 1
      ;;
  esac
done

if [[ "$OPTIND" -eq 1 ]] || [[ "$OPTIND" -lt "$#" ]]
then
  show_usage
  exit 1
fi
#shift $((OPTIND -1))

# main
if [[ "$recursive" == "yes" ]]
then
  dothier_recursive "$dothier" "$dothome" "$dotdir"
else
  read_dothier "$dothier" "$dothome"
fi
